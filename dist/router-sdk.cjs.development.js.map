{"version":3,"file":"router-sdk.cjs.development.js","sources":["../src/constants.ts","../src/approveAndCall.ts","../src/multicallExtended.ts","../src/paymentsExtended.ts","../src/entities/protocol.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/swapRouter.ts"],"sourcesContent":["import JSBI from 'jsbi'\n\nexport const MSG_SENDER = '0x0000000000000000000000000000000000000001'\nexport const ADDRESS_THIS = '0x0000000000000000000000000000000000000002'\n\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n","import { Interface } from '@ethersproject/abi'\nimport invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json'\nimport { Currency, Percent, Token } from '@uniswap/sdk-core'\nimport {\n  MintSpecificOptions,\n  IncreaseSpecificOptions,\n  NonfungiblePositionManager,\n  Position,\n  toHex,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\n// condensed version of v3-sdk AddLiquidityOptions containing only necessary swap + add attributes\nexport type CondensedAddLiquidityOptions = Omit<MintSpecificOptions, 'createPool'> | IncreaseSpecificOptions\n\nexport enum ApprovalTypes {\n  NOT_REQUIRED = 0,\n  MAX = 1,\n  MAX_MINUS_ONE = 2,\n  ZERO_THEN_MAX = 3,\n  ZERO_THEN_MAX_MINUS_ONE = 4,\n}\n\n// type guard\nexport function isMint(options: CondensedAddLiquidityOptions): options is Omit<MintSpecificOptions, 'createPool'> {\n  return Object.keys(options).some((k) => k === 'recipient')\n}\n\nexport abstract class ApproveAndCall {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeApproveMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address])\n  }\n\n  public static encodeApproveMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address])\n  }\n\n  public static encodeApproveZeroThenMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address])\n  }\n\n  public static encodeApproveZeroThenMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address])\n  }\n\n  public static encodeCallPositionManager(calldatas: string[]): string {\n    invariant(calldatas.length > 0, 'NULL_CALLDATA')\n\n    if (calldatas.length == 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas)\n    } else {\n      const encodedMulticall = NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas])\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall])\n    }\n  }\n  /**\n   * Encode adding liquidity to a position in the nft manager contract\n   * @param position Forcasted position with expected amount out from swap\n   * @param minimalPosition Forcasted position with custom minimal token amounts\n   * @param addLiquidityOptions Options for adding liquidity\n   * @param slippageTolerance Defines maximum slippage\n   */\n  public static encodeAddLiquidity(\n    position: Position,\n    minimalPosition: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    slippageTolerance: Percent\n  ): string {\n    let { amount0: amount0Min, amount1: amount1Min } = position.mintAmountsWithSlippage(slippageTolerance)\n\n    // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          fee: position.pool.fee,\n          tickLower: position.tickLower,\n          tickUpper: position.tickUpper,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          recipient: addLiquidityOptions.recipient,\n        },\n      ])\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          tokenId: toHex(addLiquidityOptions.tokenId),\n        },\n      ])\n    }\n  }\n\n  public static encodeApprove(token: Currency, approvalType: ApprovalTypes): string {\n    switch (approvalType) {\n      case ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped)\n      case ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped)\n      default:\n        throw 'Error: invalid ApprovalType'\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json'\nimport { Multicall, toHex } from '@uniswap/v3-sdk'\n\n// deadline or previousBlockhash\nexport type Validation = BigintIsh | string\n\nfunction validateAndParseBytes32(bytes32: string): string {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(`${bytes32} is not valid bytes32.`)\n  }\n\n  return bytes32.toLowerCase()\n}\n\nexport abstract class MulticallExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeMulticall(calldatas: string | string[], validation?: Validation): string {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return Multicall.encodeMulticall(calldatas)\n    }\n\n    // if there is validation, we have to normalize calldatas\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas]\n    }\n\n    // this means the validation value should be a previousBlockhash\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      const previousBlockhash = validateAndParseBytes32(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [\n        previousBlockhash,\n        calldatas,\n      ])\n    } else {\n      const deadline = toHex(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas])\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Percent, Token, validateAndParseAddress } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json'\nimport { FeeOptions, Payments, toHex } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nfunction encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n\nexport abstract class PaymentsExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeUnwrapWETH9(amountMinimum: JSBI, recipient?: string, feeOptions?: FeeOptions): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [toHex(amountMinimum)])\n    }\n  }\n\n  public static encodeSweepToken(\n    token: Token,\n    amountMinimum: JSBI,\n    recipient?: string,\n    feeOptions?: FeeOptions\n  ): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [\n        token.address,\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [\n        token.address,\n        toHex(amountMinimum),\n      ])\n    }\n  }\n\n  public static encodePull(token: Token, amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, toHex(amount)])\n  }\n\n  public static encodeWrapETH(amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [toHex(amount)])\n  }\n}\n","export enum Protocol {\n  V2 = 'V2',\n  V3 = 'V3',\n}\n","import { Route as V2RouteSDK, Pair } from '@uniswap/v2-sdk'\nimport { Route as V3RouteSDK, Pool } from '@uniswap/v3-sdk'\nimport { Protocol } from './protocol'\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\n\nexport interface IRoute<TInput extends Currency, TOutput extends Currency, TPool extends Pool | Pair> {\n  protocol: Protocol\n  // array of pools if v3 or pairs if v2\n  pools: TPool[]\n  path: Token[]\n  midPrice: Price<TInput, TOutput>\n  input: TInput\n  output: TOutput\n}\n\n// V2 route wrapper\nexport class RouteV2<TInput extends Currency, TOutput extends Currency>\n  extends V2RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair>\n{\n  public readonly protocol: Protocol = Protocol.V2\n  public readonly pools: Pair[]\n\n  constructor(v2Route: V2RouteSDK<TInput, TOutput>) {\n    super(v2Route.pairs, v2Route.input, v2Route.output)\n    this.pools = this.pairs\n  }\n}\n\n// V3 route wrapper\nexport class RouteV3<TInput extends Currency, TOutput extends Currency>\n  extends V3RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool>\n{\n  public readonly protocol: Protocol = Protocol.V3\n  public readonly path: Token[]\n\n  constructor(v3Route: V3RouteSDK<TInput, TOutput>) {\n    super(v3Route.pools, v3Route.input, v3Route.output)\n    this.path = v3Route.tokenPath\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2RouteSDK, Trade as V2TradeSDK } from '@uniswap/v2-sdk'\nimport { Pool, Route as V3RouteSDK, Trade as V3TradeSDK } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../constants'\nimport { Protocol } from './protocol'\nimport { IRoute, RouteV2, RouteV3 } from './route'\n\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  public readonly routes: IRoute<TInput, TOutput, Pair | Pool>[]\n  public readonly tradeType: TTradeType\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade. May consist of swaps in v2 or v3.\n   */\n  public readonly swaps: {\n    route: IRoute<TInput, TOutput, Pair | Pool>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  public constructor({\n    v2Routes,\n    v3Routes,\n    tradeType,\n    factoryAddress,\n    initCodeHash\n  }: {\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n    factoryAddress: string\n    initCodeHash: string\n  }) {\n    this.swaps = []\n    this.routes = []\n    // wrap v2 routes\n    for (const { routev2, inputAmount, outputAmount } of v2Routes) {\n      const route = new RouteV2(routev2)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v3 routes\n    for (const { routev3, inputAmount, outputAmount } of v3Routes) {\n      const route = new RouteV3(routev3)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    this.tradeType = tradeType\n\n    // each route must have the same input and output currency\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    invariant(\n      this.swaps.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      this.swaps.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    // pools must be unique inter protocols\n    const numPools = this.swaps.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of this.swaps) {\n      for (const pool of route.pools) {\n        if (route.protocol == Protocol.V3) {\n          poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, (pool as Pool).fee))\n        } else {\n          const pair = pool\n          poolAddressSet.add(Pair.getAddress(pair.token0, pair.token1, factoryAddress, initCodeHash))\n        }\n      }\n    }\n    invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED')\n  }\n\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return amountOut\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(amountOut.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return amountIn\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    tradeType: TTradeType,\n    factoryAddress: string,\n    initCodeHash: string\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    const populatedV2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    for (const { routev2, amount } of v2Routes) {\n      const v2Trade = new V2TradeSDK(routev2, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n\n      populatedV2Routes.push({\n        routev2,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev3, amount } of v3Routes) {\n      const v3Trade = await V3TradeSDK.fromRoute(routev3, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n\n      populatedV3Routes.push({\n        routev3,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    return new Trade({\n      v2Routes: populatedV2Routes,\n      v3Routes: populatedV3Routes,\n      tradeType,\n      factoryAddress,\n      initCodeHash\n    })\n  }\n\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: V2RouteSDK<TInput, TOutput> | V3RouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType,\n    factoryAddress: string,\n    initCodeHash: string\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    let v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n\n    let v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n\n    if (route instanceof V2RouteSDK) {\n      const v2Trade = new V2TradeSDK(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n      v2Routes = [{ routev2: route, inputAmount, outputAmount }]\n      v3Routes = []\n    } else {\n      const v3Trade = await V3TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n      v3Routes = [{ routev3: route, inputAmount, outputAmount }]\n      v2Routes = []\n    }\n    return new Trade({\n      v2Routes,\n      v3Routes,\n      tradeType,\n      factoryAddress,\n      initCodeHash\n    })\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Percent, TradeType, validateAndParseAddress, WETH9 } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport {\n  encodeRouteToPath,\n  FeeOptions,\n  MethodParameters,\n  Payments,\n  PermitOptions,\n  Position,\n  SelfPermit,\n  toHex,\n  Trade as V3Trade,\n} from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { ADDRESS_THIS, MSG_SENDER } from './constants'\nimport { ApproveAndCall, ApprovalTypes, CondensedAddLiquidityOptions } from './approveAndCall'\nimport { Trade } from './entities/trade'\nimport { Protocol } from './entities/protocol'\nimport { RouteV2, RouteV3 } from './entities/route'\nimport { MulticallExtended, Validation } from './multicallExtended'\nimport { PaymentsExtended } from './paymentsExtended'\n\nconst ZERO = JSBI.BigInt(0)\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output. If omitted, output is sent to msg.sender.\n   */\n  recipient?: string\n\n  /**\n   * Either deadline (when the transaction expires, in epoch seconds), or previousBlockhash.\n   */\n  deadlineOrPreviousBlockhash?: Validation\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\nexport interface SwapAndAddOptions extends SwapOptions {\n  /**\n   * The optional permit parameters for pulling in remaining output token.\n   */\n  outputTokenPermit?: PermitOptions\n}\n\ntype AnyTradeType =\n  | Trade<Currency, Currency, TradeType>\n  | V2Trade<Currency, Currency, TradeType>\n  | V3Trade<Currency, Currency, TradeType>\n  | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[]\n\n/**\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  private static encodeV2Swap(\n    trade: V2Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string {\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const path = trade.route.path.map((token) => token.address)\n    const recipient = routerMustCustody\n      ? ADDRESS_THIS\n      : typeof options.recipient === 'undefined'\n      ? MSG_SENDER\n      : validateAndParseAddress(options.recipient)\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams)\n    } else {\n      const exactOutputParams = [amountOut, amountIn, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams)\n    }\n  }\n\n  private static encodeV3Swap(\n    trade: V3Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      if (singleHop) {\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n        }\n      } else {\n        const path: string = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputParams = {\n            path,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n        } else {\n          const exactOutputParams = {\n            path,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  private static encodeSwaps(\n    trades: AnyTradeType,\n    options: SwapOptions,\n    isSwapAndAdd?: boolean\n  ): {\n    calldatas: string[]\n    sampleTrade: V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>\n    routerMustCustody: boolean\n    inputIsNative: boolean\n    outputIsNative: boolean\n    totalAmountIn: CurrencyAmount<Currency>\n    minimumAmountOut: CurrencyAmount<Currency>\n    quoteAmountOut: CurrencyAmount<Currency>\n  } {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual V2Trade and V3Trade objects.\n    if (trades instanceof Trade) {\n      invariant(\n        trades.swaps.every((swap) => swap.route.protocol == Protocol.V3 || swap.route.protocol == Protocol.V2),\n        'UNSUPPORTED_PROTOCOL'\n      )\n\n      let v2Andv3Trades: (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[] = []\n\n      for (const { route, inputAmount, outputAmount } of trades.swaps) {\n        if (route.protocol == Protocol.V2) {\n          v2Andv3Trades.push(\n            new V2Trade(\n              route as RouteV2<Currency, Currency>,\n              trades.tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n              trades.tradeType\n            )\n          )\n        } else if (route.protocol == Protocol.V3) {\n          v2Andv3Trades.push(\n            V3Trade.createUncheckedTrade({\n              route: route as RouteV3<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        }\n      }\n      trades = v2Andv3Trades\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades]\n    }\n\n    const numberOfTrades = trades.reduce(\n      (numberOfTrades, trade) => numberOfTrades + (trade instanceof V3Trade ? trade.swaps.length : 1),\n      0\n    )\n\n    const sampleTrade = trades[0]\n\n    // All trades should have the same starting/ending currency and trade type\n    invariant(\n      trades.every((trade) => trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency)),\n      'TOKEN_IN_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency)),\n      'TOKEN_OUT_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.tradeType === sampleTrade.tradeType),\n      'TRADE_TYPE_DIFF'\n    )\n\n    const calldatas: string[] = []\n\n    const inputIsNative = sampleTrade.inputAmount.currency.isNative\n    const outputIsNative = sampleTrade.outputAmount.currency.isNative\n\n    // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck = sampleTrade.tradeType === TradeType.EXACT_INPUT && numberOfTrades > 2\n    // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n    const routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    for (const trade of trades) {\n      if (trade instanceof V2Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck))\n      } else {\n        for (const calldata of SwapRouter.encodeV3Swap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      }\n    }\n\n    const ZERO_IN: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0)\n    const ZERO_OUT: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0)\n\n    const minimumAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)),\n      ZERO_OUT\n    )\n\n    const quoteAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.outputAmount),\n      ZERO_OUT\n    )\n\n    const totalAmountIn: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)),\n      ZERO_IN\n    )\n\n    return {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n      quoteAmountOut,\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[],\n    options: SwapOptions\n  ): MethodParameters {\n    const {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options)\n\n    // unwrap or sweep\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee))\n      } else {\n        calldatas.push(\n          PaymentsExtended.encodeSweepToken(\n            sampleTrade.outputAmount.currency.wrapped,\n            minimumAmountOut.quotient,\n            options.recipient,\n            options.fee\n          )\n        )\n      }\n    }\n\n    // must refund when paying in ETH: either with an uncertain input amount OR if there's a chance of a partial fill.\n    // unlike ERC20's, the full ETH value must be sent in the transaction, so the rest must be refunded.\n    if (inputIsNative && (sampleTrade.tradeType === TradeType.EXACT_OUTPUT || SwapRouter.riskOfPartialFill(trades))) {\n      calldatas.push(Payments.encodeRefundETH())\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: toHex(inputIsNative ? totalAmountIn.quotient : ZERO),\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapAndAddCallParameters(\n    trades: AnyTradeType,\n    options: SwapAndAddOptions,\n    position: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    tokenInApprovalType: ApprovalTypes,\n    tokenOutApprovalType: ApprovalTypes\n  ): MethodParameters {\n    const {\n      calldatas,\n      inputIsNative,\n      outputIsNative,\n      sampleTrade,\n      totalAmountIn: totalAmountSwapped,\n      quoteAmountOut,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options, true)\n\n    // encode output token permit if necessary\n    if (options.outputTokenPermit) {\n      invariant(quoteAmountOut.currency.isToken, 'NON_TOKEN_PERMIT_OUTPUT')\n      calldatas.push(SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit))\n    }\n\n    const chainId = sampleTrade.route.chainId\n    const zeroForOne = position.pool.token0.wrapped.address === totalAmountSwapped.currency.wrapped.address\n    const { positionAmountIn, positionAmountOut } = SwapRouter.getPositionAmounts(position, zeroForOne)\n\n    // if tokens are native they will be converted to WETH9\n    const tokenIn = inputIsNative ? WETH9[chainId] : positionAmountIn.currency.wrapped\n    const tokenOut = outputIsNative ? WETH9[chainId] : positionAmountOut.currency.wrapped\n\n    // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n    const amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped)\n    if (amountOutRemaining.greaterThan(CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative\n        ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient))\n        : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient))\n    }\n\n    // if input is native, convert to WETH9, else pull ERC20 token\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient))\n      : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient))\n\n    // approve token balances to NFTManager\n    if (tokenInApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType))\n    if (tokenOutApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType))\n\n    // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n    const minimalPosition = Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false,\n    })\n\n    // encode NFTManager add liquidity\n    calldatas.push(\n      ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)\n    )\n\n    // sweep remaining tokens\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO))\n    outputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO))\n\n    let value: JSBI\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient\n    } else {\n      value = ZERO\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString(),\n    }\n  }\n\n  // if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\n  private static riskOfPartialFill(trades: AnyTradeType): boolean {\n    if (Array.isArray(trades)) {\n      return trades.some((trade) => {\n        return SwapRouter.v3TradeWithHighPriceImpact(trade)\n      })\n    } else {\n      return SwapRouter.v3TradeWithHighPriceImpact(trades)\n    }\n  }\n\n  private static v3TradeWithHighPriceImpact(\n    trade:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n  ): boolean {\n    return !(trade instanceof V2Trade) && trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n  }\n\n  private static getPositionAmounts(\n    position: Position,\n    zeroForOne: boolean\n  ): { positionAmountIn: CurrencyAmount<Currency>; positionAmountOut: CurrencyAmount<Currency> } {\n    const { amount0, amount1 } = position.mintAmounts\n    const currencyAmount0 = CurrencyAmount.fromRawAmount(position.pool.token0, amount0)\n    const currencyAmount1 = CurrencyAmount.fromRawAmount(position.pool.token1, amount1)\n\n    const [positionAmountIn, positionAmountOut] = zeroForOne\n      ? [currencyAmount0, currencyAmount1]\n      : [currencyAmount1, currencyAmount0]\n    return { positionAmountIn, positionAmountOut }\n  }\n}\n"],"names":["MSG_SENDER","ADDRESS_THIS","ZERO","JSBI","BigInt","ONE","ApprovalTypes","isMint","options","Object","keys","some","k","ApproveAndCall","encodeApproveMax","token","INTERFACE","encodeFunctionData","address","encodeApproveMaxMinusOne","encodeApproveZeroThenMax","encodeApproveZeroThenMaxMinusOne","encodeCallPositionManager","calldatas","length","invariant","encodedMulticall","NonfungiblePositionManager","encodeAddLiquidity","position","minimalPosition","addLiquidityOptions","slippageTolerance","mintAmountsWithSlippage","amount0Min","amount0","amount1Min","amount1","lessThan","quotient","token0","pool","token1","fee","tickLower","tickUpper","toHex","recipient","tokenId","encodeApprove","approvalType","MAX","wrapped","MAX_MINUS_ONE","ZERO_THEN_MAX","ZERO_THEN_MAX_MINUS_ONE","Interface","abi","validateAndParseBytes32","bytes32","match","Error","toLowerCase","MulticallExtended","encodeMulticall","validation","Multicall","Array","isArray","startsWith","previousBlockhash","deadline","encodeFeeBips","multiply","PaymentsExtended","encodeUnwrapWETH9","amountMinimum","feeOptions","Payments","feeBips","feeRecipient","validateAndParseAddress","encodeSweepToken","encodePull","amount","encodeWrapETH","Protocol","RouteV2","v2Route","pairs","input","output","V2","pools","V2RouteSDK","RouteV3","v3Route","V3","path","tokenPath","V3RouteSDK","Trade","v2Routes","v3Routes","tradeType","factoryAddress","initCodeHash","swaps","routes","routev2","inputAmount","outputAmount","route","push","routev3","inputCurrency","currency","outputCurrency","every","equals","numPools","map","reduce","total","cur","poolAddressSet","Set","protocol","add","Pool","getAddress","pair","Pair","size","minimumAmountOut","amountOut","TradeType","EXACT_OUTPUT","slippageAdjustedAmountOut","Fraction","invert","CurrencyAmount","fromRawAmount","maximumAmountIn","amountIn","EXACT_INPUT","slippageAdjustedAmountIn","worstExecutionPrice","Price","fromRoutes","populatedV2Routes","populatedV3Routes","v2Trade","V2TradeSDK","V3TradeSDK","fromRoute","v3Trade","_inputAmount","totalInputFromRoutes","_outputAmount","totalOutputFromRoutes","_executionPrice","_priceImpact","spotOutputAmount","midPrice","quote","priceImpact","subtract","divide","Percent","numerator","denominator","REFUND_ETH_PRICE_IMPACT_THRESHOLD","SwapRouter","encodeV2Swap","trade","routerMustCustody","performAggregatedSlippageCheck","exactInputParams","exactOutputParams","encodeV3Swap","singleHop","exactInputSingleParams","tokenIn","tokenOut","amountOutMinimum","sqrtPriceLimitX96","exactOutputSingleParams","amountInMaximum","encodeRouteToPath","encodeSwaps","trades","isSwapAndAdd","swap","v2Andv3Trades","V2Trade","V3Trade","createUncheckedTrade","numberOfTrades","sampleTrade","inputIsNative","isNative","outputIsNative","inputTokenPermit","isToken","SelfPermit","encodePermit","calldata","ZERO_IN","ZERO_OUT","sum","quoteAmountOut","totalAmountIn","swapCallParameters","riskOfPartialFill","encodeRefundETH","deadlineOrPreviousBlockhash","value","swapAndAddCallParameters","tokenInApprovalType","tokenOutApprovalType","totalAmountSwapped","outputTokenPermit","chainId","zeroForOne","getPositionAmounts","positionAmountIn","positionAmountOut","WETH9","amountOutRemaining","greaterThan","NOT_REQUIRED","Position","fromAmounts","toString","useFullPrecision","v3TradeWithHighPriceImpact","mintAmounts","currencyAmount0","currencyAmount1"],"mappings":"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"}
{"version":3,"file":"router-sdk.cjs.production.min.js","sources":["../src/approveAndCall.ts","../src/constants.ts","../src/multicallExtended.ts","../src/paymentsExtended.ts","../src/entities/protocol.ts","../src/entities/route.ts","../src/entities/trade.ts","../src/swapRouter.ts"],"sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IApproveAndCall.sol/IApproveAndCall.json'\nimport { Currency, Percent, Token } from '@uniswap/sdk-core'\nimport {\n  MintSpecificOptions,\n  IncreaseSpecificOptions,\n  NonfungiblePositionManager,\n  Position,\n  toHex,\n} from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\n// condensed version of v3-sdk AddLiquidityOptions containing only necessary swap + add attributes\nexport type CondensedAddLiquidityOptions = Omit<MintSpecificOptions, 'createPool'> | IncreaseSpecificOptions\n\nexport enum ApprovalTypes {\n  NOT_REQUIRED = 0,\n  MAX = 1,\n  MAX_MINUS_ONE = 2,\n  ZERO_THEN_MAX = 3,\n  ZERO_THEN_MAX_MINUS_ONE = 4,\n}\n\n// type guard\nexport function isMint(options: CondensedAddLiquidityOptions): options is Omit<MintSpecificOptions, 'createPool'> {\n  return Object.keys(options).some((k) => k === 'recipient')\n}\n\nexport abstract class ApproveAndCall {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeApproveMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMax', [token.address])\n  }\n\n  public static encodeApproveMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveMaxMinusOne', [token.address])\n  }\n\n  public static encodeApproveZeroThenMax(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMax', [token.address])\n  }\n\n  public static encodeApproveZeroThenMaxMinusOne(token: Token): string {\n    return ApproveAndCall.INTERFACE.encodeFunctionData('approveZeroThenMaxMinusOne', [token.address])\n  }\n\n  public static encodeCallPositionManager(calldatas: string[]): string {\n    invariant(calldatas.length > 0, 'NULL_CALLDATA')\n\n    if (calldatas.length == 1) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', calldatas)\n    } else {\n      const encodedMulticall = NonfungiblePositionManager.INTERFACE.encodeFunctionData('multicall', [calldatas])\n      return ApproveAndCall.INTERFACE.encodeFunctionData('callPositionManager', [encodedMulticall])\n    }\n  }\n  /**\n   * Encode adding liquidity to a position in the nft manager contract\n   * @param position Forcasted position with expected amount out from swap\n   * @param minimalPosition Forcasted position with custom minimal token amounts\n   * @param addLiquidityOptions Options for adding liquidity\n   * @param slippageTolerance Defines maximum slippage\n   */\n  public static encodeAddLiquidity(\n    position: Position,\n    minimalPosition: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    slippageTolerance: Percent\n  ): string {\n    let { amount0: amount0Min, amount1: amount1Min } = position.mintAmountsWithSlippage(slippageTolerance)\n\n    // position.mintAmountsWithSlippage() can create amounts not dependenable in scenarios\n    // such as range orders. Allow the option to provide a position with custom minimum amounts\n    // for these scenarios\n    if (JSBI.lessThan(minimalPosition.amount0.quotient, amount0Min)) {\n      amount0Min = minimalPosition.amount0.quotient\n    }\n    if (JSBI.lessThan(minimalPosition.amount1.quotient, amount1Min)) {\n      amount1Min = minimalPosition.amount1.quotient\n    }\n\n    if (isMint(addLiquidityOptions)) {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('mint', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          fee: position.pool.fee,\n          tickLower: position.tickLower,\n          tickUpper: position.tickUpper,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          recipient: addLiquidityOptions.recipient,\n        },\n      ])\n    } else {\n      return ApproveAndCall.INTERFACE.encodeFunctionData('increaseLiquidity', [\n        {\n          token0: position.pool.token0.address,\n          token1: position.pool.token1.address,\n          amount0Min: toHex(amount0Min),\n          amount1Min: toHex(amount1Min),\n          tokenId: toHex(addLiquidityOptions.tokenId),\n        },\n      ])\n    }\n  }\n\n  public static encodeApprove(token: Currency, approvalType: ApprovalTypes): string {\n    switch (approvalType) {\n      case ApprovalTypes.MAX:\n        return ApproveAndCall.encodeApproveMax(token.wrapped)\n      case ApprovalTypes.MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveMaxMinusOne(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX:\n        return ApproveAndCall.encodeApproveZeroThenMax(token.wrapped)\n      case ApprovalTypes.ZERO_THEN_MAX_MINUS_ONE:\n        return ApproveAndCall.encodeApproveZeroThenMaxMinusOne(token.wrapped)\n      default:\n        throw 'Error: invalid ApprovalType'\n    }\n  }\n}\n","import JSBI from 'jsbi'\n\nexport const MSG_SENDER = '0x0000000000000000000000000000000000000001'\nexport const ADDRESS_THIS = '0x0000000000000000000000000000000000000002'\n\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\n","import { Interface } from '@ethersproject/abi'\nimport { BigintIsh } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IMulticallExtended.sol/IMulticallExtended.json'\nimport { Multicall, toHex } from '@uniswap/v3-sdk'\n\n// deadline or previousBlockhash\nexport type Validation = BigintIsh | string\n\nfunction validateAndParseBytes32(bytes32: string): string {\n  if (!bytes32.match(/^0x[0-9a-fA-F]{64}$/)) {\n    throw new Error(`${bytes32} is not valid bytes32.`)\n  }\n\n  return bytes32.toLowerCase()\n}\n\nexport abstract class MulticallExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeMulticall(calldatas: string | string[], validation?: Validation): string {\n    // if there's no validation, we can just fall back to regular multicall\n    if (typeof validation === 'undefined') {\n      return Multicall.encodeMulticall(calldatas)\n    }\n\n    // if there is validation, we have to normalize calldatas\n    if (!Array.isArray(calldatas)) {\n      calldatas = [calldatas]\n    }\n\n    // this means the validation value should be a previousBlockhash\n    if (typeof validation === 'string' && validation.startsWith('0x')) {\n      const previousBlockhash = validateAndParseBytes32(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(bytes32,bytes[])', [\n        previousBlockhash,\n        calldatas,\n      ])\n    } else {\n      const deadline = toHex(validation)\n      return MulticallExtended.INTERFACE.encodeFunctionData('multicall(uint256,bytes[])', [deadline, calldatas])\n    }\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Percent, Token, validateAndParseAddress } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/IPeripheryPaymentsWithFeeExtended.sol/IPeripheryPaymentsWithFeeExtended.json'\nimport { FeeOptions, Payments, toHex } from '@uniswap/v3-sdk'\nimport JSBI from 'jsbi'\n\nfunction encodeFeeBips(fee: Percent): string {\n  return toHex(fee.multiply(10_000).quotient)\n}\n\nexport abstract class PaymentsExtended {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  public static encodeUnwrapWETH9(amountMinimum: JSBI, recipient?: string, feeOptions?: FeeOptions): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeUnwrapWETH9(amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9WithFee(uint256,uint256,address)', [\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('unwrapWETH9(uint256)', [toHex(amountMinimum)])\n    }\n  }\n\n  public static encodeSweepToken(\n    token: Token,\n    amountMinimum: JSBI,\n    recipient?: string,\n    feeOptions?: FeeOptions\n  ): string {\n    // if there's a recipient, just pass it along\n    if (typeof recipient === 'string') {\n      return Payments.encodeSweepToken(token, amountMinimum, recipient, feeOptions)\n    }\n\n    if (!!feeOptions) {\n      const feeBips = encodeFeeBips(feeOptions.fee)\n      const feeRecipient = validateAndParseAddress(feeOptions.recipient)\n\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepTokenWithFee(address,uint256,uint256,address)', [\n        token.address,\n        toHex(amountMinimum),\n        feeBips,\n        feeRecipient,\n      ])\n    } else {\n      return PaymentsExtended.INTERFACE.encodeFunctionData('sweepToken(address,uint256)', [\n        token.address,\n        toHex(amountMinimum),\n      ])\n    }\n  }\n\n  public static encodePull(token: Token, amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('pull', [token.address, toHex(amount)])\n  }\n\n  public static encodeWrapETH(amount: JSBI): string {\n    return PaymentsExtended.INTERFACE.encodeFunctionData('wrapETH', [toHex(amount)])\n  }\n}\n","export enum Protocol {\n  V2 = 'V2',\n  V3 = 'V3',\n}\n","import { Route as V2RouteSDK, Pair } from '@uniswap/v2-sdk'\nimport { Route as V3RouteSDK, Pool } from '@uniswap/v3-sdk'\nimport { Protocol } from './protocol'\nimport { Currency, Price, Token } from '@uniswap/sdk-core'\n\nexport interface IRoute<TInput extends Currency, TOutput extends Currency, TPool extends Pool | Pair> {\n  protocol: Protocol\n  // array of pools if v3 or pairs if v2\n  pools: TPool[]\n  path: Token[]\n  midPrice: Price<TInput, TOutput>\n  input: TInput\n  output: TOutput\n}\n\n// V2 route wrapper\nexport class RouteV2<TInput extends Currency, TOutput extends Currency>\n  extends V2RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pair>\n{\n  public readonly protocol: Protocol = Protocol.V2\n  public readonly pools: Pair[]\n\n  constructor(v2Route: V2RouteSDK<TInput, TOutput>) {\n    super(v2Route.pairs, v2Route.input, v2Route.output)\n    this.pools = this.pairs\n  }\n}\n\n// V3 route wrapper\nexport class RouteV3<TInput extends Currency, TOutput extends Currency>\n  extends V3RouteSDK<TInput, TOutput>\n  implements IRoute<TInput, TOutput, Pool>\n{\n  public readonly protocol: Protocol = Protocol.V3\n  public readonly path: Token[]\n\n  constructor(v3Route: V3RouteSDK<TInput, TOutput>) {\n    super(v3Route.pools, v3Route.input, v3Route.output)\n    this.path = v3Route.tokenPath\n  }\n}\n","import { Currency, CurrencyAmount, Fraction, Percent, Price, TradeType } from '@uniswap/sdk-core'\nimport { Pair, Route as V2RouteSDK, Trade as V2TradeSDK } from '@uniswap/v2-sdk'\nimport { Pool, Route as V3RouteSDK, Trade as V3TradeSDK } from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport { ONE, ZERO } from '../constants'\nimport { Protocol } from './protocol'\nimport { IRoute, RouteV2, RouteV3 } from './route'\n\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  public readonly routes: IRoute<TInput, TOutput, Pair | Pool>[]\n  public readonly tradeType: TTradeType\n  private _outputAmount: CurrencyAmount<TOutput> | undefined\n  private _inputAmount: CurrencyAmount<TInput> | undefined\n\n  /**\n   * The swaps of the trade, i.e. which routes and how much is swapped in each that\n   * make up the trade. May consist of swaps in v2 or v3.\n   */\n  public readonly swaps: {\n    route: IRoute<TInput, TOutput, Pair | Pool>\n    inputAmount: CurrencyAmount<TInput>\n    outputAmount: CurrencyAmount<TOutput>\n  }[]\n\n  //  construct a trade across v2 and v3 routes from pre-computed amounts\n  public constructor({\n    v2Routes,\n    v3Routes,\n    tradeType,\n    factoryAddress,\n    initCodeHash\n  }: {\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n    tradeType: TTradeType\n    factoryAddress: string\n    initCodeHash: string\n  }) {\n    this.swaps = []\n    this.routes = []\n    // wrap v2 routes\n    for (const { routev2, inputAmount, outputAmount } of v2Routes) {\n      const route = new RouteV2(routev2)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    // wrap v3 routes\n    for (const { routev3, inputAmount, outputAmount } of v3Routes) {\n      const route = new RouteV3(routev3)\n      this.routes.push(route)\n      this.swaps.push({\n        route,\n        inputAmount,\n        outputAmount,\n      })\n    }\n    this.tradeType = tradeType\n\n    // each route must have the same input and output currency\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    invariant(\n      this.swaps.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)),\n      'INPUT_CURRENCY_MATCH'\n    )\n    invariant(\n      this.swaps.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)),\n      'OUTPUT_CURRENCY_MATCH'\n    )\n\n    // pools must be unique inter protocols\n    const numPools = this.swaps.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0)\n    const poolAddressSet = new Set<string>()\n    for (const { route } of this.swaps) {\n      for (const pool of route.pools) {\n        if (route.protocol == Protocol.V3) {\n          poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, (pool as Pool).fee))\n        } else {\n          const pair = pool\n          poolAddressSet.add(Pair.getAddress(pair.token0, pair.token1, factoryAddress, initCodeHash))\n        }\n      }\n    }\n    invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED')\n  }\n\n  public get inputAmount(): CurrencyAmount<TInput> {\n    if (this._inputAmount) {\n      return this._inputAmount\n    }\n\n    const inputCurrency = this.swaps[0].inputAmount.currency\n    const totalInputFromRoutes = this.swaps\n      .map(({ inputAmount }) => inputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0))\n\n    this._inputAmount = totalInputFromRoutes\n    return this._inputAmount\n  }\n\n  public get outputAmount(): CurrencyAmount<TOutput> {\n    if (this._outputAmount) {\n      return this._outputAmount\n    }\n\n    const outputCurrency = this.swaps[0].outputAmount.currency\n    const totalOutputFromRoutes = this.swaps\n      .map(({ outputAmount }) => outputAmount)\n      .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0))\n\n    this._outputAmount = totalOutputFromRoutes\n    return this._outputAmount\n  }\n\n  private _executionPrice: Price<TInput, TOutput> | undefined\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public get executionPrice(): Price<TInput, TOutput> {\n    return (\n      this._executionPrice ??\n      (this._executionPrice = new Price(\n        this.inputAmount.currency,\n        this.outputAmount.currency,\n        this.inputAmount.quotient,\n        this.outputAmount.quotient\n      ))\n    )\n  }\n\n  /**\n   * The cached result of the price impact computation\n   * @private\n   */\n  private _priceImpact: Percent | undefined\n  /**\n   * Returns the percent difference between the route's mid price and the price impact\n   */\n  public get priceImpact(): Percent {\n    if (this._priceImpact) {\n      return this._priceImpact\n    }\n\n    let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0)\n    for (const { route, inputAmount } of this.swaps) {\n      const midPrice = route.midPrice\n      spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount))\n    }\n\n    const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount)\n    this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator)\n\n    return this._priceImpact\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount out\n   */\n  public minimumAmountOut(slippageTolerance: Percent, amountOut = this.outputAmount): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return amountOut\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(amountOut.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\n   * @returns The amount in\n   */\n  public maximumAmountIn(slippageTolerance: Percent, amountIn = this.inputAmount): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return amountIn\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient\n      return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Return the execution price after accounting for slippage tolerance\n   * @param slippageTolerance the allowed tolerated slippage\n   * @returns The execution price\n   */\n  public worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput> {\n    return new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.maximumAmountIn(slippageTolerance).quotient,\n      this.minimumAmountOut(slippageTolerance).quotient\n    )\n  }\n\n  public static async fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>\n    }[],\n    tradeType: TTradeType,\n    factoryAddress: string,\n    initCodeHash: string\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    const populatedV2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    const populatedV3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[] = []\n\n    for (const { routev2, amount } of v2Routes) {\n      const v2Trade = new V2TradeSDK(routev2, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n\n      populatedV2Routes.push({\n        routev2,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    for (const { routev3, amount } of v3Routes) {\n      const v3Trade = await V3TradeSDK.fromRoute(routev3, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n\n      populatedV3Routes.push({\n        routev3,\n        inputAmount,\n        outputAmount,\n      })\n    }\n\n    return new Trade({\n      v2Routes: populatedV2Routes,\n      v3Routes: populatedV3Routes,\n      tradeType,\n      factoryAddress,\n      initCodeHash\n    })\n  }\n\n  public static async fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(\n    route: V2RouteSDK<TInput, TOutput> | V3RouteSDK<TInput, TOutput>,\n    amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType,\n    factoryAddress: string,\n    initCodeHash: string\n  ): Promise<Trade<TInput, TOutput, TTradeType>> {\n    let v2Routes: {\n      routev2: V2RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n\n    let v3Routes: {\n      routev3: V3RouteSDK<TInput, TOutput>\n      inputAmount: CurrencyAmount<TInput>\n      outputAmount: CurrencyAmount<TOutput>\n    }[]\n\n    if (route instanceof V2RouteSDK) {\n      const v2Trade = new V2TradeSDK(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v2Trade\n      v2Routes = [{ routev2: route, inputAmount, outputAmount }]\n      v3Routes = []\n    } else {\n      const v3Trade = await V3TradeSDK.fromRoute(route, amount, tradeType)\n      const { inputAmount, outputAmount } = v3Trade\n      v3Routes = [{ routev3: route, inputAmount, outputAmount }]\n      v2Routes = []\n    }\n    return new Trade({\n      v2Routes,\n      v3Routes,\n      tradeType,\n      factoryAddress,\n      initCodeHash\n    })\n  }\n}\n","import { Interface } from '@ethersproject/abi'\nimport { Currency, CurrencyAmount, Percent, TradeType, validateAndParseAddress, WETH9 } from '@uniswap/sdk-core'\nimport { abi } from '@uniswap/swap-router-contracts/artifacts/contracts/interfaces/ISwapRouter02.sol/ISwapRouter02.json'\nimport { Trade as V2Trade } from '@uniswap/v2-sdk'\nimport {\n  encodeRouteToPath,\n  FeeOptions,\n  MethodParameters,\n  Payments,\n  PermitOptions,\n  Position,\n  SelfPermit,\n  toHex,\n  Trade as V3Trade,\n} from '@uniswap/v3-sdk'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { ADDRESS_THIS, MSG_SENDER } from './constants'\nimport { ApproveAndCall, ApprovalTypes, CondensedAddLiquidityOptions } from './approveAndCall'\nimport { Trade } from './entities/trade'\nimport { Protocol } from './entities/protocol'\nimport { RouteV2, RouteV3 } from './entities/route'\nimport { MulticallExtended, Validation } from './multicallExtended'\nimport { PaymentsExtended } from './paymentsExtended'\n\nconst ZERO = JSBI.BigInt(0)\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\n/**\n * Options for producing the arguments to send calls to the router.\n */\nexport interface SwapOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  slippageTolerance: Percent\n\n  /**\n   * The account that should receive the output. If omitted, output is sent to msg.sender.\n   */\n  recipient?: string\n\n  /**\n   * Either deadline (when the transaction expires, in epoch seconds), or previousBlockhash.\n   */\n  deadlineOrPreviousBlockhash?: Validation\n\n  /**\n   * The optional permit parameters for spending the input.\n   */\n  inputTokenPermit?: PermitOptions\n\n  /**\n   * Optional information for taking a fee on output.\n   */\n  fee?: FeeOptions\n}\n\nexport interface SwapAndAddOptions extends SwapOptions {\n  /**\n   * The optional permit parameters for pulling in remaining output token.\n   */\n  outputTokenPermit?: PermitOptions\n}\n\ntype AnyTradeType =\n  | Trade<Currency, Currency, TradeType>\n  | V2Trade<Currency, Currency, TradeType>\n  | V3Trade<Currency, Currency, TradeType>\n  | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[]\n\n/**\n * Represents the Uniswap V2 + V3 SwapRouter02, and has static methods for helping execute trades.\n */\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  private static encodeV2Swap(\n    trade: V2Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string {\n    const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance).quotient)\n    const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance).quotient)\n\n    const path = trade.route.path.map((token) => token.address)\n    const recipient = routerMustCustody\n      ? ADDRESS_THIS\n      : typeof options.recipient === 'undefined'\n      ? MSG_SENDER\n      : validateAndParseAddress(options.recipient)\n\n    if (trade.tradeType === TradeType.EXACT_INPUT) {\n      const exactInputParams = [amountIn, performAggregatedSlippageCheck ? 0 : amountOut, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapExactTokensForTokens', exactInputParams)\n    } else {\n      const exactOutputParams = [amountOut, amountIn, path, recipient]\n\n      return SwapRouter.INTERFACE.encodeFunctionData('swapTokensForExactTokens', exactOutputParams)\n    }\n  }\n\n  private static encodeV3Swap(\n    trade: V3Trade<Currency, Currency, TradeType>,\n    options: SwapOptions,\n    routerMustCustody: boolean,\n    performAggregatedSlippageCheck: boolean\n  ): string[] {\n    const calldatas: string[] = []\n\n    for (const { route, inputAmount, outputAmount } of trade.swaps) {\n      const amountIn: string = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient)\n      const amountOut: string = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient)\n\n      // flag for whether the trade is single hop or not\n      const singleHop = route.pools.length === 1\n\n      const recipient = routerMustCustody\n        ? ADDRESS_THIS\n        : typeof options.recipient === 'undefined'\n        ? MSG_SENDER\n        : validateAndParseAddress(options.recipient)\n\n      if (singleHop) {\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]))\n        } else {\n          const exactOutputSingleParams = {\n            tokenIn: route.tokenPath[0].address,\n            tokenOut: route.tokenPath[1].address,\n            fee: route.pools[0].fee,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n            sqrtPriceLimitX96: 0,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [exactOutputSingleParams]))\n        }\n      } else {\n        const path: string = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT)\n\n        if (trade.tradeType === TradeType.EXACT_INPUT) {\n          const exactInputParams = {\n            path,\n            recipient,\n            amountIn,\n            amountOutMinimum: performAggregatedSlippageCheck ? 0 : amountOut,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [exactInputParams]))\n        } else {\n          const exactOutputParams = {\n            path,\n            recipient,\n            amountOut,\n            amountInMaximum: amountIn,\n          }\n\n          calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [exactOutputParams]))\n        }\n      }\n    }\n\n    return calldatas\n  }\n\n  private static encodeSwaps(\n    trades: AnyTradeType,\n    options: SwapOptions,\n    isSwapAndAdd?: boolean\n  ): {\n    calldatas: string[]\n    sampleTrade: V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>\n    routerMustCustody: boolean\n    inputIsNative: boolean\n    outputIsNative: boolean\n    totalAmountIn: CurrencyAmount<Currency>\n    minimumAmountOut: CurrencyAmount<Currency>\n    quoteAmountOut: CurrencyAmount<Currency>\n  } {\n    // If dealing with an instance of the aggregated Trade object, unbundle it to individual V2Trade and V3Trade objects.\n    if (trades instanceof Trade) {\n      invariant(\n        trades.swaps.every((swap) => swap.route.protocol == Protocol.V3 || swap.route.protocol == Protocol.V2),\n        'UNSUPPORTED_PROTOCOL'\n      )\n\n      let v2Andv3Trades: (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[] = []\n\n      for (const { route, inputAmount, outputAmount } of trades.swaps) {\n        if (route.protocol == Protocol.V2) {\n          v2Andv3Trades.push(\n            new V2Trade(\n              route as RouteV2<Currency, Currency>,\n              trades.tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n              trades.tradeType\n            )\n          )\n        } else if (route.protocol == Protocol.V3) {\n          v2Andv3Trades.push(\n            V3Trade.createUncheckedTrade({\n              route: route as RouteV3<Currency, Currency>,\n              inputAmount,\n              outputAmount,\n              tradeType: trades.tradeType,\n            })\n          )\n        }\n      }\n      trades = v2Andv3Trades\n    }\n\n    if (!Array.isArray(trades)) {\n      trades = [trades]\n    }\n\n    const numberOfTrades = trades.reduce(\n      (numberOfTrades, trade) => numberOfTrades + (trade instanceof V3Trade ? trade.swaps.length : 1),\n      0\n    )\n\n    const sampleTrade = trades[0]\n\n    // All trades should have the same starting/ending currency and trade type\n    invariant(\n      trades.every((trade) => trade.inputAmount.currency.equals(sampleTrade.inputAmount.currency)),\n      'TOKEN_IN_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.outputAmount.currency.equals(sampleTrade.outputAmount.currency)),\n      'TOKEN_OUT_DIFF'\n    )\n    invariant(\n      trades.every((trade) => trade.tradeType === sampleTrade.tradeType),\n      'TRADE_TYPE_DIFF'\n    )\n\n    const calldatas: string[] = []\n\n    const inputIsNative = sampleTrade.inputAmount.currency.isNative\n    const outputIsNative = sampleTrade.outputAmount.currency.isNative\n\n    // flag for whether we want to perform an aggregated slippage check\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck = sampleTrade.tradeType === TradeType.EXACT_INPUT && numberOfTrades > 2\n    // flag for whether funds should be send first to the router\n    //   1. when receiving ETH (which much be unwrapped from WETH)\n    //   2. when a fee on the output is being taken\n    //   3. when performing swap and add\n    //   4. when performing an aggregated slippage check\n    const routerMustCustody = outputIsNative || !!options.fee || !!isSwapAndAdd || performAggregatedSlippageCheck\n\n    // encode permit if necessary\n    if (options.inputTokenPermit) {\n      invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT')\n      calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit))\n    }\n\n    for (const trade of trades) {\n      if (trade instanceof V2Trade) {\n        calldatas.push(SwapRouter.encodeV2Swap(trade, options, routerMustCustody, performAggregatedSlippageCheck))\n      } else {\n        for (const calldata of SwapRouter.encodeV3Swap(\n          trade,\n          options,\n          routerMustCustody,\n          performAggregatedSlippageCheck\n        )) {\n          calldatas.push(calldata)\n        }\n      }\n    }\n\n    const ZERO_IN: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.inputAmount.currency, 0)\n    const ZERO_OUT: CurrencyAmount<Currency> = CurrencyAmount.fromRawAmount(sampleTrade.outputAmount.currency, 0)\n\n    const minimumAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)),\n      ZERO_OUT\n    )\n\n    const quoteAmountOut: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.outputAmount),\n      ZERO_OUT\n    )\n\n    const totalAmountIn: CurrencyAmount<Currency> = trades.reduce(\n      (sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)),\n      ZERO_IN\n    )\n\n    return {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n      quoteAmountOut,\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(\n    trades:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n      | (V2Trade<Currency, Currency, TradeType> | V3Trade<Currency, Currency, TradeType>)[],\n    options: SwapOptions\n  ): MethodParameters {\n    const {\n      calldatas,\n      sampleTrade,\n      routerMustCustody,\n      inputIsNative,\n      outputIsNative,\n      totalAmountIn,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options)\n\n    // unwrap or sweep\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        calldatas.push(PaymentsExtended.encodeUnwrapWETH9(minimumAmountOut.quotient, options.recipient, options.fee))\n      } else {\n        calldatas.push(\n          PaymentsExtended.encodeSweepToken(\n            sampleTrade.outputAmount.currency.wrapped,\n            minimumAmountOut.quotient,\n            options.recipient,\n            options.fee\n          )\n        )\n      }\n    }\n\n    // must refund when paying in ETH: either with an uncertain input amount OR if there's a chance of a partial fill.\n    // unlike ERC20's, the full ETH value must be sent in the transaction, so the rest must be refunded.\n    if (inputIsNative && (sampleTrade.tradeType === TradeType.EXACT_OUTPUT || SwapRouter.riskOfPartialFill(trades))) {\n      calldatas.push(Payments.encodeRefundETH())\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: toHex(inputIsNative ? totalAmountIn.quotient : ZERO),\n    }\n  }\n\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapAndAddCallParameters(\n    trades: AnyTradeType,\n    options: SwapAndAddOptions,\n    position: Position,\n    addLiquidityOptions: CondensedAddLiquidityOptions,\n    tokenInApprovalType: ApprovalTypes,\n    tokenOutApprovalType: ApprovalTypes\n  ): MethodParameters {\n    const {\n      calldatas,\n      inputIsNative,\n      outputIsNative,\n      sampleTrade,\n      totalAmountIn: totalAmountSwapped,\n      quoteAmountOut,\n      minimumAmountOut,\n    } = SwapRouter.encodeSwaps(trades, options, true)\n\n    // encode output token permit if necessary\n    if (options.outputTokenPermit) {\n      invariant(quoteAmountOut.currency.isToken, 'NON_TOKEN_PERMIT_OUTPUT')\n      calldatas.push(SelfPermit.encodePermit(quoteAmountOut.currency, options.outputTokenPermit))\n    }\n\n    const chainId = sampleTrade.route.chainId\n    const zeroForOne = position.pool.token0.wrapped.address === totalAmountSwapped.currency.wrapped.address\n    const { positionAmountIn, positionAmountOut } = SwapRouter.getPositionAmounts(position, zeroForOne)\n\n    // if tokens are native they will be converted to WETH9\n    const tokenIn = inputIsNative ? WETH9[chainId] : positionAmountIn.currency.wrapped\n    const tokenOut = outputIsNative ? WETH9[chainId] : positionAmountOut.currency.wrapped\n\n    // if swap output does not make up whole outputTokenBalanceDesired, pull in remaining tokens for adding liquidity\n    const amountOutRemaining = positionAmountOut.subtract(quoteAmountOut.wrapped)\n    if (amountOutRemaining.greaterThan(CurrencyAmount.fromRawAmount(positionAmountOut.currency, 0))) {\n      // if output is native, this means the remaining portion is included as native value in the transaction\n      // and must be wrapped. Otherwise, pull in remaining ERC20 token.\n      outputIsNative\n        ? calldatas.push(PaymentsExtended.encodeWrapETH(amountOutRemaining.quotient))\n        : calldatas.push(PaymentsExtended.encodePull(tokenOut, amountOutRemaining.quotient))\n    }\n\n    // if input is native, convert to WETH9, else pull ERC20 token\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeWrapETH(positionAmountIn.quotient))\n      : calldatas.push(PaymentsExtended.encodePull(tokenIn, positionAmountIn.quotient))\n\n    // approve token balances to NFTManager\n    if (tokenInApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenIn, tokenInApprovalType))\n    if (tokenOutApprovalType !== ApprovalTypes.NOT_REQUIRED)\n      calldatas.push(ApproveAndCall.encodeApprove(tokenOut, tokenOutApprovalType))\n\n    // represents a position with token amounts resulting from a swap with maximum slippage\n    // hence the minimal amount out possible.\n    const minimalPosition = Position.fromAmounts({\n      pool: position.pool,\n      tickLower: position.tickLower,\n      tickUpper: position.tickUpper,\n      amount0: zeroForOne ? position.amount0.quotient.toString() : minimumAmountOut.quotient.toString(),\n      amount1: zeroForOne ? minimumAmountOut.quotient.toString() : position.amount1.quotient.toString(),\n      useFullPrecision: false,\n    })\n\n    // encode NFTManager add liquidity\n    calldatas.push(\n      ApproveAndCall.encodeAddLiquidity(position, minimalPosition, addLiquidityOptions, options.slippageTolerance)\n    )\n\n    // sweep remaining tokens\n    inputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenIn, ZERO))\n    outputIsNative\n      ? calldatas.push(PaymentsExtended.encodeUnwrapWETH9(ZERO))\n      : calldatas.push(PaymentsExtended.encodeSweepToken(tokenOut, ZERO))\n\n    let value: JSBI\n    if (inputIsNative) {\n      value = totalAmountSwapped.wrapped.add(positionAmountIn.wrapped).quotient\n    } else if (outputIsNative) {\n      value = amountOutRemaining.quotient\n    } else {\n      value = ZERO\n    }\n\n    return {\n      calldata: MulticallExtended.encodeMulticall(calldatas, options.deadlineOrPreviousBlockhash),\n      value: value.toString(),\n    }\n  }\n\n  // if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\n  private static riskOfPartialFill(trades: AnyTradeType): boolean {\n    if (Array.isArray(trades)) {\n      return trades.some((trade) => {\n        return SwapRouter.v3TradeWithHighPriceImpact(trade)\n      })\n    } else {\n      return SwapRouter.v3TradeWithHighPriceImpact(trades)\n    }\n  }\n\n  private static v3TradeWithHighPriceImpact(\n    trade:\n      | Trade<Currency, Currency, TradeType>\n      | V2Trade<Currency, Currency, TradeType>\n      | V3Trade<Currency, Currency, TradeType>\n  ): boolean {\n    return !(trade instanceof V2Trade) && trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n  }\n\n  private static getPositionAmounts(\n    position: Position,\n    zeroForOne: boolean\n  ): { positionAmountIn: CurrencyAmount<Currency>; positionAmountOut: CurrencyAmount<Currency> } {\n    const { amount0, amount1 } = position.mintAmounts\n    const currencyAmount0 = CurrencyAmount.fromRawAmount(position.pool.token0, amount0)\n    const currencyAmount1 = CurrencyAmount.fromRawAmount(position.pool.token1, amount1)\n\n    const [positionAmountIn, positionAmountOut] = zeroForOne\n      ? [currencyAmount0, currencyAmount1]\n      : [currencyAmount1, currencyAmount0]\n    return { positionAmountIn, positionAmountOut }\n  }\n}\n"],"names":["ApprovalTypes","MSG_SENDER","ADDRESS_THIS","ZERO","JSBI","BigInt","ONE","isMint","options","Object","keys","some","k","ApproveAndCall","encodeApproveMax","token","INTERFACE","encodeFunctionData","address","encodeApproveMaxMinusOne","encodeApproveZeroThenMax","encodeApproveZeroThenMaxMinusOne","encodeCallPositionManager","calldatas","length","invariant","encodedMulticall","NonfungiblePositionManager","encodeAddLiquidity","position","minimalPosition","addLiquidityOptions","slippageTolerance","mintAmountsWithSlippage","amount0Min","amount0","amount1Min","amount1","lessThan","quotient","token0","pool","token1","fee","tickLower","tickUpper","toHex","recipient","tokenId","encodeApprove","approvalType","MAX","wrapped","MAX_MINUS_ONE","ZERO_THEN_MAX","ZERO_THEN_MAX_MINUS_ONE","Interface","abi","MulticallExtended","encodeMulticall","validation","Multicall","Array","isArray","startsWith","previousBlockhash","bytes32","match","Error","toLowerCase","validateAndParseBytes32","deadline","encodeFeeBips","multiply","Protocol","PaymentsExtended","encodeUnwrapWETH9","amountMinimum","feeOptions","Payments","feeBips","feeRecipient","validateAndParseAddress","encodeSweepToken","encodePull","amount","encodeWrapETH","RouteV2","v2Route","_this","pairs","input","output","V2","pools","_inheritsLoose","V2RouteSDK","RouteV3","v3Route","_this2","V3","path","tokenPath","V3RouteSDK","Trade","v2Routes","v3Routes","tradeType","factoryAddress","initCodeHash","this","swaps","routes","inputAmount","outputAmount","route","routev2","push","routev3","inputCurrency","currency","outputCurrency","every","equals","numPools","map","reduce","total","cur","poolAddressSet","Set","protocol","add","Pool","getAddress","Pair","size","_proto","minimumAmountOut","amountOut","TradeType","EXACT_OUTPUT","slippageAdjustedAmountOut","Fraction","invert","CurrencyAmount","fromRawAmount","maximumAmountIn","amountIn","EXACT_INPUT","slippageAdjustedAmountIn","worstExecutionPrice","Price","fromRoutes","populatedV2Routes","populatedV3Routes","v2Trade","V2TradeSDK","_step5$value","_iterator6","_context","_step6$value","V3TradeSDK","fromRoute","v3Trade","_context2","key","get","_inputAmount","totalInputFromRoutes","_outputAmount","totalOutputFromRoutes","_executionPrice","_priceImpact","spotOutputAmount","midPrice","quote","priceImpact","subtract","divide","Percent","numerator","denominator","REFUND_ETH_PRICE_IMPACT_THRESHOLD","SwapRouter","encodeV2Swap","trade","routerMustCustody","performAggregatedSlippageCheck","encodeV3Swap","singleHop","tokenIn","tokenOut","amountOutMinimum","sqrtPriceLimitX96","amountInMaximum","encodeRouteToPath","encodeSwaps","trades","isSwapAndAdd","swap","v2Andv3Trades","V2Trade","V3Trade","createUncheckedTrade","numberOfTrades","sampleTrade","inputIsNative","isNative","outputIsNative","inputTokenPermit","isToken","SelfPermit","encodePermit","ZERO_IN","ZERO_OUT","sum","quoteAmountOut","totalAmountIn","swapCallParameters","riskOfPartialFill","encodeRefundETH","calldata","deadlineOrPreviousBlockhash","value","swapAndAddCallParameters","tokenInApprovalType","tokenOutApprovalType","totalAmountSwapped","outputTokenPermit","chainId","zeroForOne","getPositionAmounts","positionAmountIn","positionAmountOut","WETH9","amountOutRemaining","greaterThan","NOT_REQUIRED","Position","fromAmounts","toString","useFullPrecision","v3TradeWithHighPriceImpact","mintAmounts","currencyAmount0","currencyAmount1"],"mappings":"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"}